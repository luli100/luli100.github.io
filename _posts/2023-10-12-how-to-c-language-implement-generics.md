---
layout: post
title: C 语言如何实现泛型
enable: true
---

C 语言是过程式编程语言，C 语言设计的目标是提供一种能以简易的方式编译、处理底层内存产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。而对于更高阶、更抽象的编程范式来说，C 语言这种基于过程和底层的设计初衷就会成为它的短板。因为，在编程世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务、更为抽象的语言，比如 C#。

当然，C 语言也提供了一点抽象能力和范型编程能力。

### 从一个简单的例子说起

从一个交换两个变量值的 swap 函数说起，代码如下：

```C
int swap(int* x, int* y)
{
	int temp = *x;
	*x = *y;
	*y = temp;
}
```

这个函数最大的问题，就是它只能给 int 类型的值使用，如果我们想交换两个 double 类型的值，还得写另外一个 swap 函数：

```C
double swap(double* x, double* y)
{
	double temp = *x;
	*x = *y;
	*y = temp;
}
```

float、struct 等类型，该如何是好？利用泛型对数据类型进行抽象，C 语言的类型泛型基本上来说就是使用 void * 关键字或宏定义。

### swap 函数的泛型版本 1（void *）

使用 void * 泛型版本的 swap 函数，代码如下：

```C
void swap(void* x, void* y, const int size)
{
	char* temp = malloc(size);
	memcpy(temp, y, size);
	memcpy(y, x, size);
	memcpy(x, temp, size);
}
```

这个实现方式有三个重点：

**函数接口中增加了一个 size 参数。** 这是因为，用了 void* 之后，类型被“抽象”掉了，编译器不能通过类型得到内存占用大小，因此，需要添加一个 size 来标识类型占用字节的长度。

**swap 函数实现中使用了 memcpy() 函数。** 还是因为类型被抽象掉了，不能用赋值表达式，因此只能用内存复制的方法了。

**swap 函数实现中使用了 malloc() 函数。** 这就是交换数据时，需要用的临时存储空间。

现在的 swap 函数新增的 size 参数，使用 memcpy 内存拷贝函数以及 malloc 动态内存分配函数，增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度提升。

### swap 函数的泛型版本 2（宏定义）

除了使用 void* 来做泛型之外，在 C 语言中，还可以使用**宏定义**来做泛型，代码如下：

```C
#define swap(x,y,size) \
{\
	char p = malloc(size); \
	memcpy(temp, &x, size); \
	memcpy(&x, &y, size); \
	memcpy(&y, temp, size); \
}
```

因为宏的本质是做字符替换，使用宏会导致代码膨胀的问题，导致编译出的执行文件比较大。

不过，对于 swap 这个简单的函数来说，用 void* 和 宏替换都可以达到泛型。如果是 min() 或 max() 函数，那么宏替换会暴露更多的问题。比如，对于下面的这个宏：

```C
#define min(x, y) ((x) > (y) ? (y) > (x))
```

其中，最大的问题，就是有可能会有**重复执行**的问题。如：

**min(i++, j++)** 对这个示例来说，我们本意是比较完后，对变量 i 和 j 做累加，实际情况却会导致变量 i 或 j 被累加两次。

**min(foo(), bar())** 对这示例来说，我们本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后，foo() 或 bar() 函数会被调用两次。

### swap 函数泛型的其它问题

对于 void* 和 宏定义版本，都加了一个 size。这是因为不加入 size 的话，那么我们函数内部就需要自己检查 size，然而，void* 这种地址方式是没法得到 size 的。而宏定义方式，虽然不会把类型给隐藏掉，可以使用向 sizeof(x) 这样的方式得到size。但如果类型是 char*，使用 sizeof 方式只能得到指针类型的size，而不是指针指向数据的 size。另外，对于不同类型，比如说 double 和 int，那么应该使用谁的 size 呢？这些都是问题。

于是，这种泛型，我们根本没有办法检查传入参数的 size，我们只能加入一个 size 参数，从而增加函数接口的复杂度，然后把问题抛给调用者。

